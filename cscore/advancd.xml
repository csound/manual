<?xml version="1.0" encoding="UTF-8"?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" id="CscoreAdvancd">
  <title>More Advanced Examples</title>

  <para>
    The following program demonstrates reading from two different input files. The idea is to switch between two 2-section scores, and write out the interleaved sections to a single output file.
  </para>

  <para>
    <informalexample>
      <programlisting>
#include "cscore.h"              /*   CSCORE_SWITCH.C  */ 
cscore(CSOUND* cs)               /* callable from either Csound or standalone cscore */ 
{ 
  EVLIST *a, *b; 
  FILE   *fp1, *fp2;                      /* declare two scorefile stream pointers */ 
  fp1 = cscoreFileGetCurrent(cs);         /* this is the command-line score */ 
  fp2 = cscoreFileOpen(cs, "score2.srt"); /* this is an additional score file */ 
  a = cscoreListGetSection(cs);           /* read section from score 1 */ 
  cscoreListPut(cs, a);                   /* write it out as is */ 
  cscorePutString(cs, "s"); 
  cscoreFileSetCurrent(cs, fp2); 
  b = cscoreListGetSection(cs);           /* read section from score 2 */ 
  cscoreListPut(cs, b);                   /* write it out as is */ 
  cscorePutString(cs, "s"); 
  cscoreListFreeEvents(cs, a);            /* optional to reclaim space */ 
  cscoreListFreeEvents(cs, b);
  cscoreFileSetCurrent(cs, fp1); 
  a = cscoreListGetSection(cs);           /* read next section from score 1 */ 
  cscoreListPut(cs, a);                   /* write it out */ 
  cscorePutString(cs, "s"); 
  cscoreFileSetCurrent(cs, fp2); 
  b = cscoreListGetSection(cs);           /* read next sect from score 2 */ 
  cscoreListPut(cs, b);                   /* write it out */ 
  cscorePutString(cs, "e");
}</programlisting>
    </informalexample>
  </para>

  <para>
    Finally, we show how to take a literal, uninterpreted score file and imbue it with some expressive timing changes. The theory of composer-related metric pulses has been investigated at length by Manfred Clynes, and the following is in the spirit of his work. The strategy here is to first create an <emphasis>array</emphasis> of new <emphasis>onset</emphasis> times for every possible sixteenth-note onset, then to index into it so as to adjust the start and duration of each note of the input score to the interpreted time-points. This also shows how a Csound orchestra can be invoked repeatedly from a run-time score generator.
  </para>

  <para>
    <informalexample>
      <programlisting>
#include "cscore.h"              /*   CSCORE_PULSE.C  */ 
  
/* program to apply interpretive durational pulse to     */ 
/* an existing score in 3/4 time, first beats on 0, 3, 6 ... */
  
  
static float four[4] = { 1.05, 0.97, 1.03, 0.95 };   /* pulse width for 4's */ 
static float three[3] = { 1.03, 1.05, .92 };         /* pulse width for 3's */ 
  
   
cscore(CSOUND* cs)            /* This example should be called from Csound  */ 
{ 
  EVLIST  *a, *b; 
  EVENT  *e, **ep; 
  float pulse16[4*4*4*4*3*4];    /* 16th-note array, 3/4 time, 256 measures */ 
  float acc16, acc1,inc1, acc3,inc3, acc12,inc12, acc48,inc48, acc192,inc192; 
  float *p = pulse16; 
  int  n16, n1, n3, n12, n48, n192; 

  /* fill the array with interpreted ontimes  */ 
  for (acc192=0.,n192=0; n192&lt;4; acc192+=192.*inc192,n192++) 
    for (acc48=acc192,inc192=four[n192],n48=0; n48&lt;4; acc48+=48.*inc48,n48++) 
      for (acc12=acc48,inc48=inc192*four[n48],n12=0;n12&lt;4; acc12+=12.*inc12,n12++) 
        for (acc3=acc12,inc12=inc48*four[n12],n3=0; n3&lt;4; acc3+=3.*inc3,n3++) 
          for (acc1=acc3,inc3=inc12*four[n3],n1=0; n1&lt;3; acc1+=inc1,n1++) 
            for (acc16=acc1,inc1=inc3*three[n1],n16=0; n16&lt;4; acc16+=.25*inc1*four[n16],n16++) 
              *p++ = acc16; 
   
  
  /* for (p = pulse16, n1 = 48; n1--; p += 4)  /* show vals &amp; diffs */ 
  /*   printf("%g %g %g %g %g %g %g %g\n", *p, *(p+1), *(p+2), *(p+3), 
  /*  *(p+1)-*p, *(p+2)-*(p+1), *(p+3)-*(p+2), *(p+4)-*(p+3)); */ 
  
  a = cscoreListGetSection(cs);                /* read sect from tempo-warped score */ 
  b = cscoreListSeparateTWF(cs, a);            /* separate warp &amp; fn statements */ 
  cscoreListPlay(cs, b);                       /* and send these to performance */ 
  a = cscoreListAppendStringEvent(cs, a, "s"); /* append a sect statement to note list */ 
  cscoreListPlay(cs, a);                       /* play the note-list without interpretation */ 
  for (ep = &amp;a-&gt;e[1], n1 = a-&gt;nevents; n1--; ) { /* now pulse-modifiy it */ 
    e = *ep++; 
    if (e-&gt;op == 'i') { 
      e-&gt;p[2] = pulse16[(int)(4. * e-&gt;p2orig)]; 
      e-&gt;p[3] = pulse16[(int)(4. * (e-&gt;p2orig + e-&gt;p3orig))] - e-&gt;p[2]; 
    } 
  } 
  
  cscoreListPlay(cs, a);                       /* now play modified list */
}</programlisting>
    </informalexample>
  </para>
</section>
